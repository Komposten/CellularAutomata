Option 1:
- Change Cell3D to be static.
- Instead of having a Cell3D[], have a static array of "CellTypes" (e.g. to represent different "blocks"), size = width*height*depth.
- When calculating vertices, use Cell3D.getVertices(x, y, z, Type). It calculates the vertices and returns them in an array (stored in Cell3D, always the same to avoid creating new arrays every time).
   * E.g. use the returned array to populate GridMesh3D's array with the cell's vertices.
- Cells are updated through updateCell() as usual.
- When refreshMesh() is called, all cells are gone through to create a new vertex array to pass to the mesh.


Option 2: Less memory than current, with no change in CPU time.
- Change Cell3D to be static.
- Instead of having a Cell3D[], have a CellType[], size = width*height*depth.
- Use Cell3D.getVertices(x, y, z, CellType) to calculate vertices.
   * CellType.Empty means no vertices are calculated.
- Use a HashMap to store the vertices, with the index as key and the vertices as value. Increment a vertexCount variable for every vertex that is added.
- Create a mesh by going through map.values() and adding all vertices to an array of size vertexCount.
- When updating a cell, simply replace its array in the HashMap with a new one (if a face was added/removed) or modify its values (if a colour was changed).
- When "removing" a cell, just remove it from the HashMap.


Option 3: Less memory than option 2, but more CPU required (since vertices are not calculated ahead of time).
- Store neither Cell3Ds nor CellTypes in a full-size array.
- In a HashMap, store information as follows:
   key = index
   value = [CellType1; CellType2; VisibleFaces; r; g; b], where VisibleFaces is a byte using bits to store values (e.g. [00011101] = [-FrontLeftRight-Top]. value is a byte[], using 2 bytes to store CellType, 1 for faces and 3 for colour.
- Create a mesh by going through map.values() and calculating vertex positions for each cell's faces (e.g. if the cell has a front-face, call front(x, y, z, r, g, b, vertexArray, offset) to add a front face for the cell at [x, y, z] and put the data at vertexArray[offset]->vertexArray[offset+8]).
- When updating a cell, simply modify its data in the HashMap (adding/removing bits if a face was added/removed, changing its colour values, etc.)
- When "removing" a cell, just remove it from the HashMap.
   

Memory currently:
- Cell3D[262 144] = 2 097 152 //References
- Cell3D.boolean[2 621 440] = 23 068 672 //References and values
- Cell3D.Vertex[9 437 184] = 77 594 624 //References
- Vertex.float[84 934 656] = 339 738 624 //Values
- float[42 467 328] = 169 869 312 //vertex array
- float[42 467 328] = 169 869 312 //float array
- Total: 952 107 008

Memory for option 2:
- CellType[262 144] = 2 097 152 //enum references
- map.int[262144] = 3 145 728 //key references and values
- map.float[324]*262144/2 = 173 015 040 //value references, value arrays, and values
- float[42 467 328] = 169 869 312 //vertex array
- Total: 348 127 232
- Estimated savings: 63%

Memory for option 3:
- map.int[262144] = 3 145 728 //key references and values
- map.short[262144*6] = 5 242 880 //value references and values
- float[42 467 328] = 169 869 312 //vertex array
- Total: 176 685 056
- Estimated savings: 81%
- Actual savings: 84%
- Other notes: The mesh is created 15-16 times faster (probably because there are much fewer objects to create).



